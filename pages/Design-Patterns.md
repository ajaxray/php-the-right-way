---
layout: page
title:  Design Patterns
sitemap: true
---

# ডিজাইন প্যাটার্ন

আপনার ওয়েব অ্যাপ্লিকেশনের জন্য কোড এবং প্রজেক্ট স্ট্রাকচার করার অনেক উপায় রয়েছে, এবং সেক্ষেত্রে আপনি অনেক বা সামান্য চিন্তাধারা আর্কিটেকচার ঠিক করতে
ব্যবহার করতে পারেন। কিন্তু এটি সাধারণত একটি ভাল ধারণা যে সাধারণ প্যাটার্ন অনুসরণ করা, কারণ এটা আপনার কোডকে সহজে ম্যানেজ করতে এবং অন্যদের 
সহজে বুঝতে সহায়তা করবে।  

* [উইকিপিডিয়াতে আর্কিটেকচারাল প্যাটার্ন](https://en.wikipedia.org/wiki/Architectural_pattern)
* [উইকিপিডিয়াতে সফটওয়্যার ডিজাইন প্যাটার্ন](https://en.wikipedia.org/wiki/Software_design_pattern)
* [কিছু ইম্প্লিমেন্টেশানের উদাহরণ](http://designpatternsphp.readthedocs.io/en/latest/)

## ফ্যাক্টরি প্যাটার্ন

সবচেয়ে সাধারণ ব্যবহৃত ডিজাইন প্যাটার্নগুলির একটি হচ্ছে ফ্যাক্টরি প্যাটার্ন। এই প্যাটার্নে একটি ক্লাস কেবল যে অবজেক্ট আপনি ব্যবহার করতে চান তা তৈরি করে।
ফ্যাক্টরি প্যাটার্নের নিম্নলিখিত উদাহরণ বিবেচনা করুন:

{% highlight php %}
<?php
class Automobile
{
    private $vehicleMake;
    private $vehicleModel;

    public function __construct($make, $model)
    {
        $this->vehicleMake = $make;
        $this->vehicleModel = $model;
    }

    public function getMakeAndModel()
    {
        return $this->vehicleMake . ' ' . $this->vehicleModel;
    }
}

class AutomobileFactory
{
    public static function create($make, $model)
    {
        return new Automobile($make, $model);
    }
}

// have the factory create the Automobile object
$veyron = AutomobileFactory::create('Bugatti', 'Veyron');

print_r($veyron->getMakeAndModel()); // outputs "Bugatti Veyron"
{% endhighlight %}

এই কোডটি অটোমোবাইল অবজেক্ট  তৈরির জন্য একটি ফ্যাক্টরি ব্যবহার করে। এইভাবে আপনার কোডটি তৈরীর জন্য এই দুটি সম্ভাব্য সুবিধা রয়েছে;
প্রথমটি হলো পরবর্তীতে যদি কখনো আপনি অটোমোবাইল ক্লাসটি পরিবর্তন, নাম পরিবর্তন অথবা রিপ্লেস করতে চান তাহলে শুধু ফ্যাক্টরি ক্লাসে পরিবর্তন করলেই চলবে, 
সমস্ত প্রজেক্টের যত জায়গায় অটোমোবাইল ক্লাস ব্যবহার করা হয়েছে সব জায়গায় পরিবর্তনের পরিবর্তে। দ্বিতীয় সম্ভাব্য সুবিধা হল যে যদি অবজেক্ট তৈরি করা একটি 
জটিল কাজ হয় তাহলে আপনি সব কাজ করতে পারেন এই ফ্যাক্টরি ক্লাসে, প্রতিবার অবজেক্ট তৈরী করার সময়ে করার পরিবর্তে।  

ফ্যাক্টরি প্যাটার্ন ব্যবহার করা সবসময় (বা বুদ্ধিমান) প্রয়োজন নাও হতে পারে। এখানে ব্যবহৃত উদাহরণ কোড এত সহজ যে ফ্যাক্টরি ক্লাস এখানে সহজেই অপ্রয়োজনীও 
জটিলতা যোগ করবে। যাইহোক, যদি আপনি একটি বেশ বড় বা জটিল প্রজেক্টে কাজ করেন তাহলে ফ্যাক্টরি ক্লাসের ব্যবহার হয়তো আপনার ভবিষৎ অনেক সমস্যা কমিয়ে দিবে।


* [ফ্যাক্টরি প্যাটার্ন উইকিপিডিয়াতে](https://en.wikipedia.org/wiki/Factory_pattern)

## সিঙ্গেলটন প্যাটার্ন

যখন ওয়েব অ্যাপ্লিকেশন ডিজাইন করা হয় তখন প্রায়ই ধারনাগত এবং স্থাপত্যগতভাবে একটি নির্দিষ্ট ক্লাসের এক এবং শুধুমাত্র একটি ইন্সটান্স আক্সেস করার প্রয়োজন 
হতে পারে। সিঙ্গেলটন প্যাটার্ন আমাদের এটা করতে সহায়তা করে।

**যা করতে হবে : নতুন সিঙ্গেলটন কোড উদাহরণ প্রয়োজন **

উপরের কোডটি স্ট্যাটিক ভেরিয়েবল এবং [*স্ট্যাটিক*](http://php.net/language.variables.scope#language.variables.scope.static) নির্মাণ 
পদ্ধতি `getInstance ()` ব্যবহার করে সিঙ্গেলটন প্যাটার্ন ইমপ্লিমেন্ট করে।
নিম্নলিখিত নোট দ্রষ্টব্য:

* কন্সট্রাকটর [`__construct()`](http://php.net/language.oop5.decon#object.construct) কে প্রটেক্টেড হিসাবে ডিক্লেয়ার করা হয় যাতে `new` 
অপারেটর দ্বারা ক্লাসের বাইরে থেকে কোন নতুন ইন্সটান্স তৈরী করা না যায়।
* ম্যাজিক মেথড [`__clone()`](http://php.net/language.oop5.cloning#object.clone) কে প্রাইভেট হিসাবে ডিক্লেয়ার করা হয় যাতে ক্লাসের 
ইন্সটান্স কে [`clone`](http://php.net/language.oop5.cloning) অপারেটর দ্বারা ক্লোন করা না যায়। 
* ম্যাজিক মেথড [`__wakeup()`](http://php.net/language.oop5.magic#object.wakeup) কে প্রাইভেট হিসাবে ডিক্লেয়ার করা হয় যাতে ক্লাসের 
ইন্সটান্স কে গ্লোবাল ফ্যাংশান [`unserialize()`](http://php.net/function.unserialize) দ্বারা আনসিরিয়ালাইজিং করা না যায়। 
* নতুন ইন্সট্যান্স [লেট্ স্ট্যাটিক বাইন্ডিং ](http://php.net/language.oop5.late-static-bindings) দ্বারা স্ট্যাটিক তৈরীর মেথড `getInstance()`
`static` শব্দ দ্বারা। এটা `Singleton` ক্লাসের 

সিঙ্গেলটন প্যাটার্নটি দরকারি যখন আমরা নিশ্চিত করতে চাই যে একটি ওয়েব অ্যাপ্লিকেশনের সমগ্র রিকুয়েস্ট জীবনচক্রে কেবলমাত্র একটি ক্লাসের একটি ইন্সট্যান্স থাকবে। 
এটি সাধারণত ঘটে যখন আমাদের গ্লোবাল অবজেক্ট (যেমন একটি কনফিগারেশন ক্লাস) বা একটি শেয়ার্ড রিসোর্স (যেমন একটি ইভেন্ট কিউ হিসাবে) থাকে।

আপনার সতর্ক থাকতে হবে সিঙ্গেলটন প্যাটার্ন ব্যবহার করার সময় এটার প্রকৃতির জন্য যেহেতু এটা আপনার অ্যাপ্লিকেশনের গ্লোবাল স্টেট কে প্রবর্তন করবে, 
এবং টেস্ট করার ক্ষমতা কমাবে। অধিকাংশ ক্ষেত্রে ডিপেন্ডেন্সি ইঞ্জেকশন সিঙ্গেলটন ক্লাসের জায়গায় ব্যবহার করা যায় (এবং উচিত)। ডিপেন্ডেন্সি ইঞ্জেকশন ব্যবহার করার
মানে আমরা আমাদের অ্যাপ্লিকেশনের ডিজাইনের অপ্রয়োজনীও ক্যাপলিং ইন্ট্র্রুডিউস করবো না, যেমন ভাবে শেয়ার্ড এবং গ্লোবাল অবজেক্ট ব্যবহার করার ক্ষেত্রে সুনির্দিষ্ট বা
নিখুঁত ভাবে ডিফাইন্ড করা ক্লাসের সম্বন্ধে কোন জ্ঞান লাগে না।

* [উইকিপিডিয়াতে সিঙ্গেলটন প্যাটার্ন](https://en.wikipedia.org/wiki/Singleton_pattern)

## স্ট্রাটেজি প্যাটার্ন 

স্ট্রাটেজি প্যাটার্নের দ্বারা আপনি নির্দিষ্ট কিছু এলগরিদমকে এনক্যাপ্সুলেট করতে পারেন, যা ক্লায়েন্ট ক্লাস কোন বিশেষ এলগরিদমের বাস্তবায়ন সম্বন্ধে কোন কিছু 
না জেনেই এলগোরিদমকে ইন্সট্যান্সিয়েট করার জন্য রিস্পন্সিবল। স্ট্রাটেজি প্যাটার্নের বিভিন্ন বৈচিত্র আছে, যার সবচেয়ে সহজলভ্যতা নিচে দেওয়া হয়েছে:

এই প্রথম কোড স্নিপেট অ্যালগরিদমের একটি ফ্যামিলি রূপরেখা; আপনি হয়তো একটি সিরিয়ালাইজড অ্যারে, কিছু JSON বা হয়তো শুধু একটি ড্যাটার অ্যারে চাইতে 
পারেন:

{% highlight php %}
<?php

interface OutputInterface
{
    public function load();
}

class SerializedArrayOutput implements OutputInterface
{
    public function load()
    {
        return serialize($arrayOfData);
    }
}

class JsonStringOutput implements OutputInterface
{
    public function load()
    {
        return json_encode($arrayOfData);
    }
}

class ArrayOutput implements OutputInterface
{
    public function load()
    {
        return $arrayOfData;
    }
}
{% endhighlight %}

উপরের অ্যালগোরিদমগুলি এন্ক্যাপ্সুলেট করার দ্বারা আপনি আপনার কোডকে সুন্দর এবং স্পষ্ট করে তুলছেন, যাতে অন্যান্য ডেভেলপাররা সহজেই ক্লায়েন্ট কোডকে
প্রভাবিত না করে নতুন আউটপুট টাইপ যোগ করতে পারবে।

আপনি দেখতে পাবেন কিভাবে প্রতিটি কংক্রিট 'output' ক্লাস একটি OutputInterface কে ইমপ্লিমেন্ট করেছে - এটি দুটি উদ্দেশ্যে সাধন করে, 
প্রথমত এটি একটি সহজ কন্টাক্ট প্রদান করে যে, কোনও নতুন কংক্রিটের ইমপ্লিমেন্টেশন সেটা মেনে চলতে হবে। দ্বিতীয়ত একটি কমন  ইন্টারফেস ইমপ্লেমেন্টেশন 
দ্বারা আপনি [টাইপ হিন্টিং](http://php.net/language.oop5.typehinting) ব্যবহার করতে পারবেন যেটা পরবর্তী অধ্যায়ে দেখতে পারবেন। 
আর এটা নিশ্চিত করে যে ক্লায়েন্ট 'OutputInterface' এর ক্ষেত্রে সঠিক টাইপের বিহেভিয়র ব্যবহার করে। 

কোড আউটলাইন পরবর্তী স্নিপেটে আমরা দেখবো কিভাবে ক্লায়েন্ট ক্লাস ঐ অ্যালগরিদমের মধ্যে একটি কে ব্যবহার করতে পারে এবং কিভাবে আরও ভালো ভাবে 
রানটাইমে বিহেভিয়ার সেট করতে পারে:

{% highlight php %}
<?php
class SomeClient
{
    private $output;

    public function setOutput(OutputInterface $outputType)
    {
        $this->output = $outputType;
    }

    public function loadOutput()
    {
        return $this->output->load();
    }
}
{% endhighlight %}

উপরের ক্লায়েন্ট ক্লাসের একটি ব্যক্তিগত প্রোপার্টি আছে যেটা অবশ্যই রানটাইমে সেট করতে হবে এবং সেটা 'OutputInterface' এর টাইপ হতে হবে। 
যখন এই প্রোপার্টি সেট হয়ে যাবে, তখন loadOutput() ফ্যাংশান যেই আউটপুট টাইপ কংক্রিট ক্লাসকে সেট করা হয়ে ছিল সেই ক্লাসের  load() মেথড কে কল করবে। 

{% highlight php %}
<?php
$client = new SomeClient();

// Want an array?
$client->setOutput(new ArrayOutput());
$data = $client->loadOutput();

// Want some JSON?
$client->setOutput(new JsonStringOutput());
$data = $client->loadOutput();

{% endhighlight %}

* [স্ট্রাটেজি প্যাটার্ন উইকিপিডিয়াতে](http://en.wikipedia.org/wiki/Strategy_pattern)

## ফ্রন্ট কন্ট্রোলার

ফ্রন্ট কন্ট্রোলার প্যাটার্ন হল যেখানে আপনার ওয়েব অ্যাপ্লিকেশনের (e.g. index.php) জন্য আপনার একক এন্ট্রি পয়েন্ট আছে যেটা সব রিকুয়েষ্ট হ্যান্ডেল করে। 
এই কোড সমস্ত ডিপেন্ডেনসি লোড করা, রিকুয়েষ্ট প্রক্রিয়াজাত করা এবং ব্রাউজারে রেসপন্স পাঠানোর জন্য দায়ী। ফ্রন্ট কন্ট্রোলার প্যাটার্ন উপকারী হতে পারে কারণ 
এটা মডুলার কোড করা কে উৎসাহ দেয় এবং আপনাকে কোডে হুক রাখার একটি কেন্দ্রীয় স্থান দেয় যা প্রতিটি রিকুয়েষ্টের জন্য চালানো উচিত (যেমন ইনপুট সানিটাইজেশান)।

* [উইকিপিডিয়াতে ফ্রন্ট কন্ট্রোলার প্যাটার্ন](https://en.wikipedia.org/wiki/Front_Controller_pattern)

## মডেল-ভিউ-কন্ট্রোলার প্যাটার্ন

মডেল-ভিউ-কন্ট্রোলার (এমভিসি) প্যাটার্ন এবং এর সতীর্থ এইচএমভিসি এবং এমভিভিএম আপনাকে লজিক্যাল অবজেক্টের মধ্যে কোড আলাদা করতে দেয় যা খুব নির্দিষ্ট উদ্দেশ্যে 
পরিবেশন করে। মডেল ডেটা অ্যাক্সেস লেয়ার হিসাবে কাজ করে যেখানে ডেটা লোড করা হয় এবং আপনার অ্যাপ্লিকেশন জুড়ে ব্যবহারযোগ্য ফরম্যাটে ফিরে দেয়। 
কন্ট্রোলার রিকুয়েষ্ট হ্যান্ডেল করে, মডেল থেকে পাওয়া ডাটা প্রক্রিয়া করে এবং ভিউস লোড করে সেখানে ডাটা পাঠিয়ে দেয়। এবং ভিউগুলো টেম্পলেট 
(মার্কআপ, এক্সএমএল ইত্যাদি) গুলোকে প্রদর্শন করে যেগুলো রেসপন্স আকারে  ওয়েব ব্রাউজারে পাঠানো হয়। 

এমভিসি জনপ্রিয় [পিএইচপি ফ্রেমওয়ারর্কে](https://github.com/codeguy/php-the-right-way/wiki/Frameworks) ব্যবহৃত সবচেয়ে কমন আর্কিটেকচ্যারাল প্যাটার্ন

এমভিসি এবং তার আত্মীয় সম্পর্কে আরও জানুন:

* [এমভিসি](https://en.wikipedia.org/wiki/Model%E2%80%93View%E2%80%93Controller)
* [এইচএমভিসি](https://en.wikipedia.org/wiki/Hierarchical_model%E2%80%93view%E2%80%93controller)
* [এমভিভিএম](https://en.wikipedia.org/wiki/Model_View_ViewModel)
